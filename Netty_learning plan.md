## 近期学习计划-8.9
#### 1.Netty权威指南-共25章，计划每章2天。共50天，中间穿插基础知识积累。

#### 第五章:分隔符和定长解码器的应用：
##### day01-8.9:
 - 5.1 DelimiterBasedFrameDecoder
   - TCP粘包/拆包：TCP是个“流”协议，所谓流，就是没有界限的一串数据。
**TCP底层并不了解上层业务数据的具体含义**，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据报发送,这就是所谓的TCP粘包和拆包问题。
---
code : netty-server/echo-demo
---
- 5.2 FixedLengthFrameDecoder 
   - FixedLengthFrameDecoder 是固定长度解码器，它能够按照指定的长度对消息进行自动解码，开发者不需要考虑TCP的粘包/拆包问题；
   - 利用FixedLengthFrameDecoder解码器，无论一次接受到多少数据报，它都会按照构造函数中设置的固定长度进行解码，
   如果是半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包；
   - 测试，利用telnet；
      - 先启动一个telnet程序连接到TCP服务器中
      - 在连接上的TCP服务器的telnet程序窗口中同时按下 "Ctrl" 和 "]" ,接着在提示窗口中执行
        set localecho命令,按下回车,命令执行,再次按下回车,退出当前窗口 ,会来到一个新的
        telnet窗口,在此窗口中输入的内容就可以显示出来了
---
code : netty-server/echo-demo
--- 
#### 第六章：编解码技术
##### day02-8.10：
 - java序列化的目的主要有两个
    - 网络传输
    - 对象持久化
 - 6.1 java序列化的缺点
    - 6.1.1 无法跨语言
    - 6.1.2 序列化后的码流太大
    - 6.1.3 序列化性能太低
 - 6.2 业界主流的编解码框架
    - Google 的 Protobuf
    - Facebook 的Thrift
    - JBoss Marshalling

 ---
#### 第七章：MessagePack编解码
##### day03-8.11:
- 7.1 MessagePack 介绍
  - MessagePack是一个高效的**二进制**序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。
  - 编码高效，性能高；
  - 序列化之后的码流小；
  - 支持跨语言；
  - api使用：
 ---
 code ： messagepack/MsgAPIDemo
 ---
 ##### day04-8.12:
- 7.2 MessagePack 编码器和解码器开发
  - code ： messagepack/
- 7.3 功能测试、粘包、半包支持
   - 遗留：ctx.write();和ctx.writeAndFlush()区别
   
---   
    code : messagepack
---
##### 明日：线程池、各种加密算法 
##### day05-8.13:
 - 加密算法 （涉及原理和使用场景，具体底层实现没有研究。）
 - 对称加密算法
    - 对称加密顾名思义就是加密和解密是对称的，加密时用一个秘钥去加密，解密时用同一个秘钥去解密，由信息发送方
    和接收方共同约定一个秘钥。缺点是风险都在这个秘钥上面，一旦被窃取，信息会暴露。所以安全级别不够高。
    常用对称加密算法有DES，3DES，AES等
 - 非对称加密算法
    -非对称加密，顾名思义就是加密与解密的过程不是对称的，不是用的同一个秘钥。非对称加密有个公私钥对的概念，
    也就是有两把秘钥，一把是公钥，一把是私钥，** 一对公私钥有固定的生成方法，在加密的时候，用公钥去加密，
    接收方再用对应的私钥去解密**。
    - 使用时可以由接收方生成公私钥对，然后将公钥传给加密方，这样私钥不会在网络中传输，
         没有被窃取的风险。比如github底层的ssh协议就是公私钥非对称加密。**并且公钥是可以由私钥推导出来的，反过来却不行**，
         由通过公钥无法推导出私钥。常用算法有RSA，ECC等。ECC也是比特币底层用的比较多的算法。通过和对称加密的对比，
         可以看到，非对称加密解决了秘钥传输中的安全问题。
    - 非对称加密也有一个问题，就是内容在发送前可能被篡改，因为公钥是有可能被窃取的，所以窃取者完全可以改为发送别的内容。
    - 解决的办法就是数字签名。数字签名和非对称加密是反过来的，也是有公私钥对，但是是用私钥签名，用公钥去验证签名。
    比如发送方除了发送用公钥加密后的密文，还要发送签名，签名内容通常是密文哈希后的字符串，
    接收方首先验证签名是否正确，如果正确那么密文解密后就是真正需要并且没有被篡改过的内容。**签名和非对称用的是两对不同的公私钥。**
 - 哈希算法
    - 简单说就是**将任意数据都转换成一个固定长度的字符串**。**通过哈希后的值几乎无法推导出原文**。而且两个不同的原文哈希后结果
    一定不同。常用算法有MD5，SHA256等等。常用场景，md5常用场景是数据库的密码存储。sha256在挖矿中可以用到。
 - 数字签名
 #### 第八章：Google Protobuf编解码 (第八章、第九章编解码内容先跳过，直接开始第十章) 
 ##### day06-8.14:
  - JAVAssist：
     - Javassist是一个开源的分析、编辑和创建**Java字节码**的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。
     它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。
  - **8.1 Protobuf 入门**
#### 第十章：HTTP协议开发应用(了解)

##### day06-8.14:

---
- **10.1**
 - HTTP(超文本传输协议) 协议是建立在TCP传输协议之上的应用层协议。
 - 由于Netty的Http协议栈是基于Netty的NIO通信框架开发的，因此，Netty的HTTP协议也是异步非阻塞的
 - HTTP 协议的主要特点：
    - 支持Client/Server模式
    - 简单--客户像服务器请求服务时，只需指定服务URL，携带必要的请求参数或者消息体；
    - 灵活 -- HTTP 允许传输任意类型的 **数据对象**，传输的内容类型由HTTP 消息头中的**Content-Type** 加以标记；
    - 无状态-- HTTP 协议是无状态协议，是指协议对于事物处理没有记忆能力。
 - Netty HTTP 服务器端入门开发
    - Netty--异步事件驱动的架构
 - 10.2 Netty HTTP 服务端入门开发
  ---
 #### 第十一章：WebSocket
 ##### day07-8.15:
  - WebSocket 连接本质上就是一个TCP连接。
  - 相比HTTP，它的网络利用率更高，可以通过全双工的方式进行消息发送和接收。
  - code：web_socket
  ---
  #### 第十二章：私有协议介绍
   ##### day08-8.17:
   - 12.1 私有协议介绍
      - 私有协议本质上是厂商内部发展和采用的标准，除非授权，其他厂商一般无权使用该协议。
      - 绝大多数的私有协议传输层都基于TCP/IP,所以利用Netty的NIO TCP 协议栈可以非常方便的进行私有协议的定制和开发
   - 传统的java 应用中，通常使用以下四种方式进行跨节点通信。
      - 通过RMI进行远程服务调用
      - 通过java的Socket+java序列化的方式进行跨节点调用
      - 利用一些开源的RPC 框架进行远程调用，例如 Facebook 的Thrift、Apache 的Avro。
      - 利用标准的公有协议进行跨节点服务调用，例如HTTP + xml、restful+json 或webService。
    - 跨节点的远程服务调用，除了**链路层**的物理连接外，还需要对请求和响应消息进行编解码。
    - 私有协议并没有标准的定义，只要是能用于夸进程、跨主机数据交换的非标准协议，都可以称为私有协议。
    --- 
   - 12.2 Netty 协议栈功能设计
    - Netty 协议栈用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类似HTTP协议的应用层协议栈，相比于传统的标准协议栈，它更加轻巧、灵活和实用
    - 在分布式组网环境下，每个Netty节点之间建立长连接，使用Netty协议进行通信，Netty 节点并没有服务端和客户端的区分，
    谁首先发起连接，谁就是客户端，另一方自然就成为了服务端。
   - Netty 协议通信双方链路建立成功之后，双方之间的心跳采用ping-pong机制，当链路处于空闲状态时，客户端主动发送ping
   消息给服务端，服务端接受到ping消息后发送应答消息pong给客户端，如果客户端连续发送N条ping消息都没有接受到服务端返回的pong消息
   ，说明链路已经挂死或者对方处于异常状态，客户端主动关闭连接，间隔周期T后发起重连操作，直到重连成功。
   ---
   - 12.2.4 消息定义
   - Netty协议栈消息定义包含两部分
      - 消息头
      - 消息体
      
      - 12.2.7 链路的建立
      
      
 
 
  
   
