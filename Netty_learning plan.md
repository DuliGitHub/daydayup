## 近期学习计划-8.9
#### 1.Netty权威指南-共25章，计划每章2天。共50天，中间穿插基础知识积累。

#### 第五章:分隔符和定长解码器的应用：
##### day01-8.9:
 - 5.1 DelimiterBasedFrameDecoder
   - TCP粘包/拆包：TCP是个“流”协议，所谓流，就是没有界限的一串数据。
**TCP底层并不了解上层业务数据的具体含义**，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据报发送,这就是所谓的TCP粘包和拆包问题。
---
code : netty-server/echo-demo
---
- 5.2 FixedLengthFrameDecoder 
   - FixedLengthFrameDecoder 是固定长度解码器，它能够按照指定的长度对消息进行自动解码，开发者不需要考虑TCP的粘包/拆包问题；
   - 利用FixedLengthFrameDecoder解码器，无论一次接受到多少数据报，它都会按照构造函数中设置的固定长度进行解码，
   如果是半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包；
   - 测试，利用telnet；
      - 先启动一个telnet程序连接到TCP服务器中
      - 在连接上的TCP服务器的telnet程序窗口中同时按下 "Ctrl" 和 "]" ,接着在提示窗口中执行
        set localecho命令,按下回车,命令执行,再次按下回车,退出当前窗口 ,会来到一个新的
        telnet窗口,在此窗口中输入的内容就可以显示出来了
---
code : netty-server/echo-demo
--- 
#### 第六章：编解码技术
##### day02-8.10：
 - java序列化的目的主要有两个
    - 网络传输
    - 对象持久化
 - 6.1 java序列化的缺点
    - 6.1.1 无法跨语言
    - 6.1.2 序列化后的码流太大
    - 6.1.3 序列化性能太低
 - 6.2 业界主流的编解码框架
    - Google 的 Protobuf
    - Facebook 的Thrift
    - JBoss Marshalling

 ---
#### 第七章：MessagePack编解码
##### day03-8.11:
- 7.1 MessagePack 介绍
  - MessagePack是一个高效的**二进制**序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。
  - 编码高效，性能高；
  - 序列化之后的码流小；
  - 支持跨语言；
  - api使用：
 ---
 code ： messagepack/MsgAPIDemo
 ---
 ##### day04-8.12:
- 7.2 MessagePack 编码器和解码器开发
  - code ： messagepack/
- 7.3 功能测试、粘包、半包支持
   - 遗留：ctx.write();和ctx.writeAndFlush()区别
   
---   
    code : messagepack
---
##### 明日：线程池、各种加密算法 
##### day05-8.13:
 - 加密算法 （涉及原理和使用场景，具体底层实现没有研究。）
 - 对称加密算法
    - 对称加密顾名思义就是加密和解密是对称的，加密时用一个秘钥去加密，解密时用同一个秘钥去解密，由信息发送方
    和接收方共同约定一个秘钥。缺点是风险都在这个秘钥上面，一旦被窃取，信息会暴露。所以安全级别不够高。
    常用对称加密算法有DES，3DES，AES等
 - 非对称加密算法
    -非对称加密，顾名思义就是加密与解密的过程不是对称的，不是用的同一个秘钥。非对称加密有个公私钥对的概念，
    也就是有两把秘钥，一把是公钥，一把是私钥，** 一对公私钥有固定的生成方法，在加密的时候，用公钥去加密，
    接收方再用对应的私钥去解密**。
    - 使用时可以由接收方生成公私钥对，然后将公钥传给加密方，这样私钥不会在网络中传输，
         没有被窃取的风险。比如github底层的ssh协议就是公私钥非对称加密。**并且公钥是可以由私钥推导出来的，反过来却不行**，
         由通过公钥无法推导出私钥。常用算法有RSA，ECC等。ECC也是比特币底层用的比较多的算法。通过和对称加密的对比，
         可以看到，非对称加密解决了秘钥传输中的安全问题。
    - 非对称加密也有一个问题，就是内容在发送前可能被篡改，因为公钥是有可能被窃取的，所以窃取者完全可以改为发送别的内容。
    - 解决的办法就是数字签名。数字签名和非对称加密是反过来的，也是有公私钥对，但是是用私钥签名，用公钥去验证签名。
    比如发送方除了发送用公钥加密后的密文，还要发送签名，签名内容通常是密文哈希后的字符串，
    接收方首先验证签名是否正确，如果正确那么密文解密后就是真正需要并且没有被篡改过的内容。**签名和非对称用的是两对不同的公私钥。**
 - 哈希算法
    - 简单说就是**将任意数据都转换成一个固定长度的字符串**。**通过哈希后的值几乎无法推导出原文**。而且两个不同的原文哈希后结果
    一定不同。常用算法有MD5，SHA256等等。常用场景，md5常用场景是数据库的密码存储。sha256在挖矿中可以用到。
 - 数字签名
 #### 第八章：Google Protobuf编解码 (第八章、第九章编解码内容先跳过，直接开始第十章) 
 ##### day06-8.14:
  - JAVAssist：
     - Javassist是一个开源的分析、编辑和创建**Java字节码**的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。
     它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。
  - **8.1 Protobuf 入门**
#### 第十章：HTTP协议开发应用
##### day06-8.14:


  
   
