## 近期学习计划-8.9
#### 1.Netty权威指南-共25章，计划每章2天。共50天，中间穿插基础知识积累。

#### 第五章:分隔符和定长解码器的应用：
##### day01-8.9:
 - 5.1 DelimiterBasedFrameDecoder
   - TCP粘包/拆包：TCP是个“流”协议，所谓流，就是没有界限的一串数据。
**TCP底层并不了解上层业务数据的具体含义**，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据报发送,这就是所谓的TCP粘包和拆包问题。
---
code : netty-server/echo-demo
---
- 5.2 FixedLengthFrameDecoder 
   - FixedLengthFrameDecoder 是固定长度解码器，它能够按照指定的长度对消息进行自动解码，开发者不需要考虑TCP的粘包/拆包问题；
   - 利用FixedLengthFrameDecoder解码器，无论一次接受到多少数据报，它都会按照构造函数中设置的固定长度进行解码，
   如果是半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包；
   - 测试，利用telnet；
      - 先启动一个telnet程序连接到TCP服务器中
      - 在连接上的TCP服务器的telnet程序窗口中同时按下 "Ctrl" 和 "]" ,接着在提示窗口中执行
        set localecho命令,按下回车,命令执行,再次按下回车,退出当前窗口 ,会来到一个新的
        telnet窗口,在此窗口中输入的内容就可以显示出来了
---
code : netty-server/echo-demo
--- 
#### 第六章：编解码技术
##### day02-8.10：
 - java序列化的目的主要有两个
    - 网络传输
    - 对象持久化
 - 6.1 java序列化的缺点
    - 6.1.1 无法跨语言
    - 6.1.2 序列化后的码流太大
    - 6.1.3 序列化性能太低
 - 6.2 业界主流的编解码框架
    - Google 的 Protobuf
    - Facebook 的Thrift
    - JBoss Marshalling

 ---
#### 第七章：MessagePack编解码
##### day03-8.11:
- 7.1 MessagePack 介绍
  - MessagePack是一个高效的**二进制**序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。
  - 编码高效，性能高；
  - 序列化之后的码流小；
  - 支持跨语言；
  - api使用：
 ---
 code ： messagepack/MsgAPIDemo
 ---
 ##### day04-8.12:
- 7.2 MessagePack 编码器和解码器开发
  - code ： messagepack/
- 7.3 功能测试、粘包、半包支持
   - 遗留：ctx.write();和ctx.writeAndFlush()区别
   
---   
    code : messagepack
---
##### 明日：线程池、各种加密算法 
##### day05-8.13:
 - 加密算法 （涉及原理和使用场景，具体底层实现没有研究。）
 - 对称加密算法
    - 对称加密顾名思义就是加密和解密是对称的，加密时用一个秘钥去加密，解密时用同一个秘钥去解密，由信息发送方
    和接收方共同约定一个秘钥。缺点是风险都在这个秘钥上面，一旦被窃取，信息会暴露。所以安全级别不够高。
    常用对称加密算法有DES，3DES，AES等
 - 非对称加密算法
    -非对称加密，顾名思义就是加密与解密的过程不是对称的，不是用的同一个秘钥。非对称加密有个公私钥对的概念，
    也就是有两把秘钥，一把是公钥，一把是私钥，** 一对公私钥有固定的生成方法，在加密的时候，用公钥去加密，
    接收方再用对应的私钥去解密**。
    - 使用时可以由接收方生成公私钥对，然后将公钥传给加密方，这样私钥不会在网络中传输，
         没有被窃取的风险。比如github底层的ssh协议就是公私钥非对称加密。**并且公钥是可以由私钥推导出来的，反过来却不行**，
         由通过公钥无法推导出私钥。常用算法有RSA，ECC等。ECC也是比特币底层用的比较多的算法。通过和对称加密的对比，
         可以看到，非对称加密解决了秘钥传输中的安全问题。
    - 非对称加密也有一个问题，就是内容在发送前可能被篡改，因为公钥是有可能被窃取的，所以窃取者完全可以改为发送别的内容。
    - 解决的办法就是数字签名。数字签名和非对称加密是反过来的，也是有公私钥对，但是是用私钥签名，用公钥去验证签名。
    比如发送方除了发送用公钥加密后的密文，还要发送签名，签名内容通常是密文哈希后的字符串，
    接收方首先验证签名是否正确，如果正确那么密文解密后就是真正需要并且没有被篡改过的内容。**签名和非对称用的是两对不同的公私钥。**
 - 哈希算法
    - 简单说就是**将任意数据都转换成一个固定长度的字符串**。**通过哈希后的值几乎无法推导出原文**。而且两个不同的原文哈希后结果
    一定不同。常用算法有MD5，SHA256等等。常用场景，md5常用场景是数据库的密码存储。sha256在挖矿中可以用到。
 - 数字签名
 #### 第八章：Google Protobuf编解码 (第八章、第九章编解码内容先跳过，直接开始第十章) 
 ##### day06-8.14:
  - JAVAssist：
     - Javassist是一个开源的分析、编辑和创建**Java字节码**的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。
     它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。
  - **8.1 Protobuf 入门**
#### 第十章：HTTP协议开发应用(了解)

##### day06-8.14:

---
- **10.1**
 - HTTP(超文本传输协议) 协议是建立在TCP传输协议之上的应用层协议。
 - 由于Netty的Http协议栈是基于Netty的NIO通信框架开发的，因此，Netty的HTTP协议也是异步非阻塞的
 - HTTP 协议的主要特点：
    - 支持Client/Server模式
    - 简单--客户像服务器请求服务时，只需指定服务URL，携带必要的请求参数或者消息体；
    - 灵活 -- HTTP 允许传输任意类型的 **数据对象**，传输的内容类型由HTTP 消息头中的**Content-Type** 加以标记；
    - 无状态-- HTTP 协议是无状态协议，是指协议对于事物处理没有记忆能力。
 - Netty HTTP 服务器端入门开发
    - Netty--异步事件驱动的架构
 - 10.2 Netty HTTP 服务端入门开发
  ---
 #### 第十一章：WebSocket
 ##### day07-8.15:
  - WebSocket 连接本质上就是一个TCP连接。
  - 相比HTTP，它的网络利用率更高，可以通过全双工的方式进行消息发送和接收。
  - code：web_socket
  ---
  #### 第十二章：私有协议介绍
   ##### day08-8.17:
   - 12.1 私有协议介绍
      - 私有协议本质上是厂商内部发展和采用的标准，除非授权，其他厂商一般无权使用该协议。
      - 绝大多数的私有协议传输层都基于TCP/IP,所以利用Netty的NIO TCP 协议栈可以非常方便的进行私有协议的定制和开发
   - 传统的java 应用中，通常使用以下四种方式进行跨节点通信。
      - 通过RMI进行远程服务调用
      - 通过java的Socket+java序列化的方式进行跨节点调用
      - 利用一些开源的RPC 框架进行远程调用，例如 Facebook 的Thrift、Apache 的Avro。
      - 利用标准的公有协议进行跨节点服务调用，例如HTTP + xml、restful+json 或webService。
    - 跨节点的远程服务调用，除了**链路层**的物理连接外，还需要对请求和响应消息进行编解码。
    - 私有协议并没有标准的定义，只要是能用于**跨进程、跨主机数据交换的非标准协议**，都可以称为私有协议。

   - 12.2 Netty 协议栈功能设计
    -  Netty 协议栈用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类似HTTP协议的应用层协议栈，相比于传统的标准协议栈，它更加轻巧、灵活和实用
    - 在分布式组网环境下，每个Netty节点之间建立**长连接**，使用Netty协议进行通信，**Netty 节点并没有服务端和客户端的区分**，
    谁首先发起连接，谁就是客户端，另一方自然就成为了服务端。
   - Netty 协议通信双方链路建立成功之后，双方之间的心跳采用ping-pong机制，当链路处于空闲状态时，客户端主动发送ping
   消息给服务端，服务端接受到ping消息后发送应答消息pong给客户端，如果客户端连续发送N条ping消息都没有接受到服务端返回的pong消息
   ，说明链路已经挂死或者对方处于异常状态，客户端主动关闭连接，间隔周期T后发起重连操作，直到重连成功。
   - 12.2.4 消息定义
   - Netty协议栈消息定义包含两部分
      - 消息头
      - 消息体
      
      
##### day09-8.19:
 - 12.2.7 链路的建立
 - 客户端与服务端链路建立成功之后，由客户端发送握手请求消息，握手请求消息的定义如下：
   - 消息头的type字段值为3
   - 可选附件为个数为0
   - 消息体为空
   - 握手消息的长度为22个字节
 - 服务端接收到客户端的握手请求消息之后，如果ip校验通过，返回握手成功应答消息给客户端，应用层链路建立成功，握手应答消息定义如下
   - 消息头的type字段为4
   - 可选附件个数为0
   - 消息体为byte类型的结果，“0” 表示认证成功；“-1”表示认证失败
  - 12.2.8 链路的关闭
   - 由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接
   - 以下情况，客户端和服务端需要关闭连接
    - 当对方宕机后者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知对方rest链路，需要关闭连接，释放自身的句柄等资源，由于
    采用TCP全双工通信，通信双方都需要关闭连接，释放资源
    - 消息读取过程中，发生了I/O 异常，需要主动关闭连接
    - **心跳消息读写过程中发生了I/O异常** ？？？？？，需要主动关闭连接
    - 心跳超时，需要主动关闭连接
    - 发生编码异常等不可恢复错误时，需要主动关闭连接
   - 12.2.9
    - Netty 协议栈可能会运行在非常恶劣的网络环境中，网络超时、闪断、对方进程僵死或者处理缓慢等情况都可能发生。为了保证在这些极端异常场景下Netty协议栈任能
    正常工作后者自动恢复，需要对它的可靠性进行统一规划和设计
     -  **1、心跳机制**
     - 在凌晨等业务低谷期时段，如果发生网络闪断、连接被Hang住等网络问题时，由于没有业务消息，应用进程很难发生。到了白天业务高峰期时，会发生大量
      的网络通信失败，严重的会导致一段时间进程内无法处理业务消息，为了解决这个问题，**在网络空闲时采用心跳机制来检测链路的互通性**，一旦发现网络故障，
      立即关闭链路，主动重连
      - 当网络处于空闲状态持续时间达到T（连续周期T没有读写消息）时，客户端主动发送Ping 心跳消息给服务端
      - 如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1
      - 每当客户端接受到服务的业务消息后者Pong应答消息时，将心跳失败计数器清零，连续N次没有接受到服务端的Pong消息或者业务消息，则关闭链路，间隔INTERVAL
      时间后发起重连操作
      - 服务端网络空闲状态持续时间达到T之后，服务端将心跳失败计数器加1，只要接受到客户端发送的Ping消息或者其他业务消息，计数器清零
      - 服务端连续N次没有接收到客户端的Ping消息或者其他业务消息，则关闭链路，释放资源，等待客户端重连
      - 当读或者写心跳消息发生I/O异常的时候，说明链路已经中断，此时需要立即关闭链路，如果是客户端，需要重新发起连接，如果服务端，需要清空缓存的半包信息，等待客户端重连。
    - **2、重连机制**
     -  如果链路中断，等待INTERVAL时间后，由客户端发起重连操作，如果连接失败，间隔周期INTERVAL 后再次发起重连，直到重连成功
     - 为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待INTERVAL 时间之后再发起重连，而不是失败后就立即重连
    - **3、重复登录保护**
     - 当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复登录，以防止客户端在异常状态下反复重连导致句柄资源被耗尽
     - 拒绝重复登录
     - 为了防止由服务端和客户端对链路状态理解不一致的客户端无法握手成功的问题，当服务端连续N次心跳超时之后需要主动关闭链路，清空该客户端的地址缓存消息，
     以保证后续该客户端可以重连成功，防止被重复登录保护机制拒绝掉
    -**4、消息缓存重发**
     - 无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。
     - 考虑到内存溢出的风险，**建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息**
    - **5、安全性设计**
     - 白名单、安全认证机制
    - **6、可扩展性设计**
     - Netty 协议栈架构需要具备一定的扩展能力，例如统一的消息拦截，接口日志，安全、加解密等，类似Servlet 的Filter Chain 和AOP，但考虑到性能因素，不推荐
     通过AOP来实现功能的扩展
     
##### day10-8.21:
##### Netty 协议栈开发
 - 12.3.1 数据结构定义
 - code :netty/netty_private_protocol 
 
 ##### day11-8.22:
 ##### 第十五章：ByteBuf 和相关辅助类（12-14章跳过）
  - 15.1 ByteBuf 功能说明
  - 7 种基础类型（Boolean除外） 都有自己的缓冲区实现。
  - ByteBuffer 局限性
   - ByteBuffer 长度固定，一旦分配完成，容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer 的容量时，会发生索引越界异常
   - ByteBuffer 只有一个标示位置的指针 position ，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些api
   - ByteBuffer 的API功能有限，一些高级和实用的特性不支持，需要使用者自己编程实现
   - 为了弥补这些不足，Netty 提供了自己的ByteBuffer 实现-ByteBuf
  - ByteBuf 两个指针，readerIndex 和 writerIndex;分别控制写操作和都操作，读操作的下标不会超过写操纵的下标，还可以把读取的部分清空
  - ByteBuffer 为了避免可写空间不够，每次put操作都会对空间进行校验，空间不足会创建一个新的ByteBuffer ，并将之前的ByteBuffer 复制到新的ByteBuffer中 最后释放老的ByteBuffer
  - ByteBuf 对write 操作进行了封装，由ByteBuf的write操作负责进行剩余可用空间的检验。会自动扩展，但是不要操作设置的最大缓冲区容量。

 
  ##### day12-8.23:
   - ByteBuf 的功能介绍
   - discardReadBytes 清空已经读取的区域，节约内存----调用discardReadBytes 会发生字节数组的内存复制，频繁使用会导致性能下降
   - Mark JDK 的ByteBuffer，调用mark 操作会将当前位置指针备份到mark 变量中，当调用rest操作之后，从新将指针的当前位置恢复为备份在mark中的值（回滚）
   
   ``` 
   public final Buffer mark(){
         mark = position;
         return this;
         
         
    public final Buffer reset(){
        int m = mark;
        if(m < 0){
        throw new InvalidarkException(); 
        }
        position = m;
        return this;
    }
          
  ```
---
   - Netty 的ByteBuf 中类似rest 和mark 的接口
      - markReaderIndex ： 将当前的readerIndex备份到 markedReaderIndex中；
      - resetReaderIndex : 将当前的readerIndex 设置为 markedReaderIndex；
      - markWriterIndex 、resetWriterIndex 类似
   - 查找操作
    - indexOf(int fromIndex,int toIndex,byte value);从当前ByteBuf中定位出首次出现value 的位置。没有找到返回-1
    - 还有还有很多api
    
##### day13-8.24:
 - ByteBuf 源码分析
 - 从内存分配的角度看，ByteBuf可以分为两类
    - 堆内存(HeapByteBuf)字节缓冲区：特点是**内存的分配和回收速度快**，可以被JVM自动回收；缺点是，如果进行Socket的I/O读写，
    需要**额外做一次内存复制**，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定程度的下降
    - 直接内存(DirectByteBuf)字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，**分配和回收速度慢一些**，但是
    将它写入或者从SocketChannel中读取时，由于**少一次内存复制，速度比堆内存快**   
    - 经验表明，ByteBuf的最佳实践是在I/O通信线程的读写缓冲区使用DirectByteBuf，后端业务消息的编解码模块使用HeapByteBuf
 
 
 ##### 第十六章：Channel 和 Unsafe
 ##### day14-8.25:
 - Unsafe 是个内部接口，**聚合**在Channel 中**协助**进行网络读写相关的操作，因为设计初衷是Chanel 的内部辅助类，
 不应该被Netty框架的上层使用者使用，所以被命名为Unsafe。不能仅从字面理解认为它是不安全的操作。
 
     
    
      
      
 
 
  
   
